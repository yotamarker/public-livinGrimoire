package com.yotamarker.eyeresearch;

import android.graphics.Bitmap;
import android.graphics.Color;
import android.media.MediaPlayer;
import android.support.constraint.solver.widgets.Rectangle;

public class AEye {
    public int outlinePixel = 30; // limit how dark an outline pixel is
    private double clusterPercent = 0.05;// fatness of outline of shapes (sand blast out)
    private int minObjectSize = 40; // how small an objext detected can be
    private int x; // coordinates of grid area to work on
    private int y;
    private AEyeClassifier eyeObj = new AEyeClassifier();
    private boolean[] shiberArray = new boolean[] { false, false, false, false, false, false, false, false, false };
    private int shiberCounter = 0; // active shiber
    public void setXY(int x1, int y1) {
        // change
        x = x1;
        y = y1;
    }
    private void setXY(int n) {
        y = (n + 3)/3;
        x = ((n % 3) + 1);
    }
    public void setMinObjectSize(int newVal) {
        // set minimum detectable item size
        if ((newVal >= 13)) {
            minObjectSize = newVal;
        }

    }

    public boolean overlappingRectangles(Rectangle R1, Rectangle R2) {
        // check if 2 rectangles overlap
        if (((R1.x > (R2.x + R2.width)) || ((R1.x + R1.width) < R2.x))) {
            return false;
        }

        if (((R1.y > (R2.y + R2.height)) || ((R1.y + R1.height) < R2.y))) {
            return false;
        }

        return true;
    }

    public void setClusterPercent(double newVal) {
        if (((newVal <= 1) && (newVal >= 0))) {
            clusterPercent = newVal;
        }

    }
    public Boolean is_pixel_dark_at(int xPos, int Ypos, Bitmap image, int DarkPixel) {
        int color = image.getPixel(x, y);
        int r= Color.red(color);;
        int g= Color.green(color);;
        int b=Color.blue(color);;
        if (((r < DarkPixel)
                && ((g < DarkPixel)
                && (b < DarkPixel)))) {
            return true;
        }
        else {
            return false;
        }

    }
    @Deprecated
    public Boolean isOutLine(int xPos, int Ypos, Bitmap image, int bias) {
        Boolean result = false;
        byte change = 0;
        if (((xPos > 0)
                && ((xPos
                < (image.getWidth() - 1))
                && ((Ypos > 0)
                && (Ypos
                < (image.getHeight() - 1)))))) {
            int color4;
            int color5;
            int color8;
            color8 = image.getPixel(xPos, (Ypos + 1));
            color4 = image.getPixel((xPos - 1), Ypos);
            color5 = image.getPixel(xPos, Ypos);
            if ((((Color.red(color5))
                    > ((Color.red(color4)) - bias))
                    && ((Color.red(color5))
                    < ((Color.red(color4)) + bias)))) {
                change++;
            }

            if ((((Color.green(color5))
                    > ((Color.green(color4)) - bias))
                    && ((Color.green(color5))
                    < ((Color.green(color4)) + bias)))) {
                change++;
            }

            if ((((Color.blue(color5))
                    > ((Color.blue(color4)) - bias))
                    && ((Color.blue(color5))
                    < ((Color.blue(color4)) + bias)))) {
                change++;
            }

            if ((((Color.red(color5))
                    > ((Color.red(color8)) - bias))
                    && ((Color.red(color5))
                    < ((Color.red(color8)) + bias)))) {
                change++;
            }

            if ((((Color.green(color5))
                    > ((Color.green(color8)) - bias))
                    && ((Color.green(color5))
                    < ((Color.green(color8)) + bias)))) {
                change++;
            }

            if ((((Color.blue(color5))
                    > ((Color.blue(color8)) - bias))
                    && ((Color.blue(color5))
                    < ((Color.blue(color8)) + bias)))) {
                change++;
            }

        }

        if ((change == 6)) {
            result = true;
        }

        return result;
    }
    public Bitmap mark_dark_pixel(int x, int y, Bitmap bmp1, byte marker) {
        /* marker : size of marking around marked pixel (will show as colored square)
        x,y : pixels location
        * */
        for (int i = 0; (i <= marker); i++) {
            for (int j = 0; (j <= marker); j++) {
                try {
                    bmp1.setPixel((x + j), (y + i),Color.GREEN);
                }
                catch (Exception ex) {
                }

            }

        }
        return bmp1;
    }
    public Bitmap mark_dark_pixel(int x, int y, Bitmap bmp1, byte marker, int colorDotEnum) {
        /* marker : size of marking around marked pixel (will show as colored square)
        x,y : pixels location
        colorDotEnum : example : Color.Green
        * */
        for (int i = 0; (i <= marker); i++) {
            for (int j = 0; (j <= marker); j++) {
                try {
                    bmp1.setPixel((x + j), (y + i),colorDotEnum);
                }
                catch (Exception ex) {
                }

            }

        }
        return bmp1;
    }
    public Bitmap mark_dark_pixel_white(int x, int y, Bitmap bmp1, byte marker) {
        /* marker : size of marking around marked pixel (will show as colored square)
        x,y : pixels location
        * */
        return mark_dark_pixel(x,y,bmp1 ,(byte)marker,  Color.WHITE);
    }
    public Bitmap mark_dark_pixel_black(int x, int y, Bitmap bmp1, byte marker) {
        /* marker : size of marking around marked pixel (will show as colored square)
        x,y : pixels location
        * */
        return mark_dark_pixel(x,y,bmp1 ,(byte)marker,  Color.BLACK);
    }
    public Bitmap mark_dark_pixel_red(int x, int y, Bitmap bmp1, byte marker) {
        /* marker : size of marking around marked pixel (will show as colored square)
        x,y : pixels location
        * */
        return mark_dark_pixel(x,y,bmp1 ,(byte)marker,  Color.RED);
    }
    public Bitmap mark_dark_pixel_blue(int x, int y, Bitmap bmp1, byte marker) {
        /* marker : size of marking around marked pixel (will show as colored square)
        x,y : pixels location
        * */
        return mark_dark_pixel(x,y,bmp1 ,(byte)marker,  Color.BLUE);
    }
    public char getPixelColor(int pixel) {
        //  r= red, g = green, b = blue
        int r = Color.red(pixel);
        int g = Color.green(pixel);
        int b = Color.blue(pixel);
        if((r>245)&&(g>245)&&(b>245)){return 'w';}//white
        //if(){}
        if((r<60)&&(g<60)&&(b<60)){return 'k';}// kuro in japanese
        if((r>g)&&(g>b)&&(g<100)){return 'r';}//red
        if((r>g)&&(g>b)&&(g>200)){return 'y';}//yellow
        if((r>g)&&(g>b)&&((g<200)&&(g>100))){return 'o';}//orange
        if(bigTosmall(g,r,b)||bigTosmall(g,b,r)){return 'g';}//green
        if(bigTosmall(b,g,r)){return 'b';}//blue
        if(bigTosmall(b,r,g)||((r>b)&&(g<20))){return 'v';}//violet

        return 'u';//undifiend
    }
    public char getPixelColorV2(int pixel) {
        //  r= red, g = green, b = blue
        int r = Color.red(pixel);
        int g = Color.green(pixel);
        int b = Color.blue(pixel);
        //black or white
        if(bigTosmall(r+6,g,r-6)&&bigTosmall(r+6,b,r-6)){if(miner(100,r,g,b)==100){return 'w';}else if(maxer(100,r,g,b)==100){return 'k';}}
        if(maxer(65,r,g,b)==65){return 'k';}
        if(bigTosmall(g,r,b)||bigTosmall(g,b,r)){return 'g';}//green
        if(bigTosmall(b+6,g,b-6)&&(maxer(r,g,b)==r)){return 'r';}//red
        if(bigTosmall(g+6,r,g-6)&&bigTosmall(r+6,g,b)){return  'y';}//yellow
        if(bigTosmall(r,g,b)){return  'o';}//orange
        if(bigTosmall(b+6,g,b-6)&&(bigTosmall(b+6,g,r))){return 'a';}//azure
        if(bigTosmall(b,g,r)||bigTosmall(b,r,g)){return  'b';}//blue
        if(bigTosmall(b+6,r,b-6)&&bigTosmall(r+6,b,g+50)){return 'v';}//violet
        if(bigTosmall(r,b,g)){return 'p';}//pink
        return 'w';//white
    }
    public char getPixelColorBlackOrWhite(int pixel) {
        //rapid ver for checking if the pixel black
        //  r= red, g = green, b = blue
        int r = Color.red(pixel);
        int g = Color.green(pixel);
        int b = Color.blue(pixel);
        //black or white
        if(bigTosmall(r+6,g,r-6)&&bigTosmall(r+6,b,r-6)){if(maxer(100,r,g,b)==100){return 'k';}}
        if(maxer(65,r,g,b)==65){return 'k';}
        return 'w';//white
    }
    public Boolean bigTosmall(int ... a)
            // return true if input nums decend in value
    {
        for (int i = 0; i < a.length - 1; i++) {
            if (!(a[i] > a[i + 1])) {
                return false;
            }
        }
        return true;
    }
    public String colorChartoString(String ch){
        switch(ch) {
            case "r" :
                return "red";
            case "g" :
                return "green";
            case "b" :
                return "blue";
            case "k" :
                return "black";
            case "w" :
                return "white";
            case "o" :
                return "orange";
            case "p" :
                return "pink";
            case "a" :
                return "azure";
            case "v" :
                return "violet";
            case "y" :
                return "yellow";
            default :
        }
        return  "";
    }
    public static int miner(int... a) {
        //returns array minimum
        int minimum = a[0];
        for (int i = 1; i < a.length; i++) {
            if (a[i] < minimum) {
                minimum = a[i];
            }
        }
        return minimum;
    }

    public static int maxer(int... a) {
        // returns array maximum
        int maximum = a[0];
        for (int i = 1; i < a.length; i++) {
            if (a[i] > maximum) {
                maximum = a[i];
            }
        }
        return maximum;
    }
}
