from __future__ import annotations
from abc import ABC, abstractmethod
from enum import Enum

'''
Failure types:
- ok: no fail
- requip: item should be added
- cloudian: algorithm goes to stand by in its Dclass
- fail: no input
'''


class enumFail(Enum):
    fail = "fail"
    requip = "requip"
    dequip = "dequip"
    cloudian = "cloudian"
    ok = "ok"


class Mutatable:
    @abstractmethod
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        ...

    @abstractmethod
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    @abstractmethod
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    @abstractmethod
    def clone(self) -> Mutatable:
        pass

    def getMutationLimit(self) -> int:
        return 0

    @abstractmethod
    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__

    @abstractmethod
    def mutation(self) -> Mutatable:
        self.clone()


class APVerbatim(Mutatable):
    '''this algorithm part says each past param verbatim'''

    def __init__(self, *args) -> None:
        super().__init__()
        self.sentences = []
        self.at = 0

        try:
            if (isinstance(args[0], list)):
                self.sentences = args[0]
                if (0 == len(self.sentences)):
                    self.at = 30
            else:
                for i in range(len(args)):
                    self.sentences.append(args[i])
        except:
            self.at = 30

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        '''TODO Auto-generated method stub'''
        axnStr = ""
        if (self.at < len(self.sentences)):
            axnStr = self.sentences[self.at]
            self.at += 1
        return axnStr

    # Override
    def failure(self, input: str) -> enumFail:
        '''TODO Auto-generated method stub'''
        return enumFail.ok

    # Override
    def completed(self) -> bool:
        '''TODO Auto-generated method stub'''
        return self.at >= len(self.sentences)

    # Override
    def clone(self) -> AbsAlgPart:
        '''TODO Auto-generated method stub'''
        return APVerbatim(self.sentences)


if __name__ == "__main__":
    testOne = APVerbatim(["hello", "how", "are", "you"])
    print("TestOne.action() should return 'hello': " + testOne.action("ear", "skin", "eye"))
    print(testOne.action("", "", ""))
    print("TestOne.completed should be false: " + str(testOne.completed()))
    testTwo = APVerbatim("hi", "I", "am", "good")
    print("TestTwo.action() should return 'hi': " + testTwo.action("ear", "skin", "eye"))
    print("TestTwo.completed should be false: " + str(testTwo.completed()))
    testThree = APVerbatim([])
    print("TestThree.action() should return an empty string: " + testThree.action("ear", "skin", "eye"))
    print("TestThree.completed should be true: " + str(testThree.completed()))
    testFour = APVerbatim()
    print("TestFour.action() should return an empty string: " + testFour.action("ear", "skin", "eye"))
    print("TestFour.completed should be true: " + str(testFour.completed()))

    # Clone testing
    testTwoClone = testTwo.clone()
    print("\nA clone of testTwo has been made, let's test it:")
    print("TestTwoClone.action() should return 'hi': " + testTwoClone.action("ear", "skin", "eye"))
    print("TestTwoClone.completed should be false: " + str(testTwoClone.completed()))