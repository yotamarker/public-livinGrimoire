from __future__ import annotations
from abc import ABC, abstractmethod
from enum import Enum
import re

''' ENUMFAIL CLASS '''


class enumFail(Enum):
    fail = "fail"  # no input
    requip = "requip"  # item should be added
    dequip = "dequip"
    cloudian = "cloudian"  # algorithm goes to stand by in its Dclass
    ok = "ok"  # no fail


''' MUTATABLE CLASS '''


class Mutatable(ABC):
    @abstractmethod
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        pass

    @abstractmethod
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    @abstractmethod
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    @abstractmethod
    def clone(self) -> Mutatable:
        pass

    def getMutationLimit(self) -> int:
        return 0

    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__

    def mutation(self) -> Mutatable:
        self.clone()


'''!!! CHILD TEST CLASS TO REMOVE !!!'''


class T1(Mutatable):
    def mutation(self) -> Mutatable:
        print("t1 mutating into t2")
        return T2()

    def clone(self) -> Mutatable:
        print("t1 cloning another t1")
        return T1()

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        pass

    # Override
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    # Override
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    # Override
    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__


'''!!! CHILD TEST CLASS TO REMOVE !!!'''


class T2(Mutatable):
    def mutation(self) -> Mutatable:
        print("t2 mutating into t1")
        return T1()

    def clone(self) -> Mutatable:
        print("t2 cloning another t2")
        return T2()

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        pass

    # Override
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    # Override
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    # Override
    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__


''' ABSDICTIONARYDB CLASS '''


class AbsDictionaryDB(ABC):
    @abstractmethod
    def save(self, key: str, value: str):
        '''Returns action string'''
        pass

    @abstractmethod
    def load(self, key: str) -> str:
        '''TODO set to return null as default if key not found !!!'''
        pass


''' ABSDICTIONARYDBSHADOW CLASS '''


class AbsDictionaryDBShadow(AbsDictionaryDB):
    '''used as a fill in class if you want to test the chobit and havent built a DB class yet'''

    # Override
    def save(self, key: str, value: str):
        pass

    # Override
    def load(self, key: str) -> str:
        return "null"


''' GRIMOIREMEMENTO CLASS '''


class GrimoireMemento:
    def __init__(self, absDictionaryDB: AbsDictionaryDB) -> None:
        super().__init__()
        self.rootToAPNumDic = {}  # string, string
        self.APNumToObjDic = {}  # string, Mutatable
        self.absDictionaryDB = absDictionaryDB

    def load(self, obj: Mutatable) -> Mutatable:
        '''load final mutation from memory of obj'''
        objName = obj.__class__.__name__
        objRoot = re.sub(r'\d+', '', objName)
        # if not in active DB try adding from external DB
        if not self.rootToAPNumDic.keys().__contains__(objRoot):
            temp = self.absDictionaryDB.load(objRoot)
            if temp != "null":
                self.rootToAPNumDic[objRoot] = temp

        if (not self.rootToAPNumDic.keys().__contains__(objRoot)):
            self.rootToAPNumDic[objRoot] = objName
            return obj

        if (self.rootToAPNumDic[objRoot] == objName):
            # the mutatable does not have mutations
            return obj
        else:
            APNum = self.rootToAPNumDic[objRoot]
            if (self.APNumToObjDic.keys().__contains__(APNum)):
                return self.APNumToObjDic[APNum].clone()
            else:
                self.loadMutations(obj, objName, objRoot)
                return self.APNumToObjDic[APNum].clone()

    def reqquipMutation(self, mutationAPName: str):
        '''save mutation'''
        self.rootToAPNumDic[re.sub(r'\d+', '', mutationAPName)] = mutationAPName
        self.absDictionaryDB.save(re.sub(r'\d+', '', mutationAPName), mutationAPName)

    def loadMutations(self, obj: Mutatable, objName: str, objRoot: str):
        '''
        make sure all the AP mutation sets of obj are present
        self assumes the last mutation mutates into the prime mutation
        '''
        mutant = obj
        end = objName
        while (True):
            self.APNumToObjDic[obj.__class__.__name__] = obj.clone()
            mutant = obj
            obj = mutant.mutation()
            if (end == obj.__class__.__name__):
                break

    def simpleLoad(self, key: str) -> str:
        return self.absDictionaryDB.load(key)

    def simpleSave(self, key: str, value: str):
        if (key.startswith("AP") or key == "" or value == ""):
            return
        self.absDictionaryDB.save(key, value)


''' APVERBATIM CLASS '''


class APVerbatim(Mutatable):
    '''this algorithm part says each past param verbatim'''

    def __init__(self, *args) -> None:
        super().__init__()
        self.sentences = []
        self.at = 0

        try:
            if (isinstance(args[0], list)):
                self.sentences = args[0]
                if (0 == len(self.sentences)):
                    self.at = 30
            else:
                for i in range(len(args)):
                    self.sentences.append(args[i])
        except:
            self.at = 30

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        '''TODO Auto-generated method stub'''
        axnStr = ""
        if (self.at < len(self.sentences)):
            axnStr = self.sentences[self.at]
            self.at += 1
        return axnStr

    # Override
    def failure(self, input: str) -> enumFail:
        '''TODO Auto-generated method stub'''
        return enumFail.ok

    # Override
    def completed(self) -> bool:
        '''TODO Auto-generated method stub'''
        return self.at >= len(self.sentences)

    # Override
    def clone(self) -> Mutatable:
        '''TODO Auto-generated method stub'''
        return APVerbatim(self.sentences)


''' ALGORITHM CLASS '''


# A step by step plan to achieve a goal
class Algorithm:

    def __init__(self, goal: str, representation: str, algParts: list[Mutatable]):  # list of Mutatable
        super().__init__()
        self.goal = goal
        self.representation = representation
        self.algParts = algParts

    # *constract with string and goal
    @property
    def getGoal(self) -> str:
        return self.goal

    @property
    def getRepresentation(self) -> str:
        return self.representation

    @property
    def getAlgParts(self) -> list[Mutatable]:
        return self.algParts

    def getSize(self) -> int:
        return len(self.algParts)

    def clone(self) -> Algorithm:
        parts = []  # list of Mutatable
        for mutatable in self.algParts:
            parts.append(mutatable.clone())
        return Algorithm(self.goal, self.getRepresentation, parts)


''' CLDBOOL CLASS '''


class CldBool:
    # cloudian : this class is used to provide shadow reference to a boolean variable
    def __init__(self):
        self.modeActive = False

    @property
    def getModeActive(self) -> bool:
        return self.modeActive

    def setModeActive(self, modeActive: bool):
        self.modeActive = modeActive


''' APCLDVERBATIM CLASS '''


class APCldVerbatim(Mutatable):
    '''this algorithm part says each string param verbatim'''

    def __init__(self, cldBool: CldBool, *words):
        super().__init__()
        self.sentences = []
        self.at = 0
        self.cldBool = cldBool

        try:
            if (isinstance(words[0], list)):
                self.sentences = words[0]
                self.cldBool.setModeActive(True)
            else:
                for i in range(len(words)):
                    self.sentences.append(words[i])
                self.cldBool.setModeActive(True)
        except:
            self.at = 30

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        # TODO Auto-generated method stub
        axnStr = ""
        if (self.at < len(self.sentences)):
            axnStr = self.sentences[self.at]
            self.at += 1

        self.cldBool.setModeActive(not (self.at >= len(self.sentences)))
        return axnStr

    # Override
    def failure(self, input: str) -> enumFail:
        # TODO Auto-generated method stub
        return enumFail.ok

    # Override
    def completed(self) -> bool:
        return self.at >= len(self.sentences)

    # Override
    def clone(self) -> Mutatable:
        # TODO Auto-generated method stub
        return APCldVerbatim(self.cldBool, self.sentences)


''' NEURON CLASS '''


# used to transport algorithms to other classes
class Neuron:
    def __init__(self) -> None:
        self.algParts: list[Algorithm] = []
        self.negativeAlgParts: list[Algorithm] = []

    def empty(self):
        self.algParts.clear()
        self.negativeAlgParts.clear()


''' DISKILLUTILS CLASS '''


class DISkillUtils:
    def verbatimGorithmOne(self, itte: Mutatable) -> Algorithm:
        # returns a simple algorithm containing 1 alg part
        representation = "util"
        algParts1: list[Mutatable] = []
        algParts1.append(itte)
        algorithm = Algorithm("util", representation, algParts1)
        return algorithm

    def verbatimGorithmTwo(self, algMarker: str, itte: Mutatable) -> Algorithm:
        # returns a simple algorithm for saying sent parameter
        representation = "util"
        algParts1: list[Mutatable] = []
        algParts1.append(itte)
        algorithm = Algorithm("util", representation, algParts1)
        return algorithm

    def customizedVerbatimGorithm(self, algMarker: str, itte: Mutatable) -> Algorithm:
        # the most stable and advanced algorithm builder
        # returns a simple algorithm containing 1 alg part
        representation = "r_" + algMarker
        algParts1: list[Mutatable] = []
        algParts1.append(itte)
        algorithm = Algorithm(algMarker, representation, algParts1)
        return algorithm

    def customizedVerbatimGorithm(self, algMarker: str, *itte: Mutatable) -> Algorithm:
        # the most stable and advanced algorithm builder
        # returns a simple algorithm containing 1 alg part
        representation = "r_" + algMarker
        algParts1: list[Mutatable] = []
        for i in range(len(itte)):
            algParts1.append(itte[i])
        algorithm = Algorithm(algMarker, representation, algParts1)
        return algorithm

    def simpleVerbatimAlgorithm(self, algMarker: str, *sayThis) -> Algorithm:
        # returns alg that says the word string (sayThis)
        return self.customizedVerbatimGorithm(algMarker, APVerbatim(*sayThis))

    def simpleCloudiandVerbatimAlgorithm(self, cldBool: CldBool, algMarker: str, *sayThis) -> Algorithm:
        # returns alg that says the word string (sayThis)
        return self.customizedVerbatimGorithm(algMarker, APCldVerbatim(cldBool, *sayThis))

    def strContainsList(self, str1: str, items: list[str]) -> str:
        # returns the 1st match between words in a string and values in a list.
        for temp in items:
            if (str1.count(temp) > 0):
                return temp
        return ""


''' KOKORO CLASS '''
'''
all action data goes through here
 * detects negatives such as : repetition, pain on various levels and failures
 * serves as a database for memories, convos and alg generations
 * can trigger revenge algs
 * checks for % of difference in input for exploration type algs
'''


class Kokoro:
    def __init__(self, absDictionaryDB: AbsDictionaryDB):
        self.emot = ""
        self.pain: dict[str, int] = {}
        self.grimoireMemento = GrimoireMemento(absDictionaryDB)
        self.toHeart: dict[str, str] = {}
        self.fromHeart: dict[str, str] = {}
        self.standBy = False

    def getEmot(self) -> str:
        return self.emot

    def setEmot(self, emot: str):
        self.emot = emot

    def getPain(self, BijuuName: str) -> int:
        try:
            value = self.pain[BijuuName]
        except:
            value = 0
        return value

    def inside(self, chi: Chi):
        pass

    def outside(self, isCompleted: bool, failure: enumFail):
        pass


''' CHI CLASS '''


class Chi(Mutatable):
    '''
    an adaptor pattern to the alg part, it also has the kokoro consiousness
    object to be aware throughout the program of what is happening all action
    data goes through this soul.
    '''

    def __init__(self, kokoro: Kokoro, ofSkill: str, aPart: Mutatable):
        super().__init__()
        self.kokoro = kokoro
        self.ofSkill = ofSkill
        self.aPart = kokoro.grimoireMemento.load(aPart)

    def actualAction(self, ear: str, skin: str, eye: str) -> str:
        return self.aPart.action(ear, skin, eye)

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        self.kokoro.inside(self)
        result = self.actualAction(ear, skin, eye)
        self.kokoro.outside(self.completed(), self.failure(""))
        return result

    # Override
    def failure(self, input: str) -> enumFail:
        # TODO Auto-generated method stub
        return self.aPart.failure(input)

    # Override
    def completed(self) -> bool:
        # TODO Auto-generated method stub
        return self.aPart.completed()

    # Override
    def clone(self) -> Mutatable:
        # TODO Auto-generated method stub
        return Chi(self.kokoro, self.ofSkill, self.aPart.clone())

    # Override
    def getMutationLimit(self) -> int:
        # TODO Auto-generated method stub
        return self.aPart.getMutationLimit()

    # Override
    def mutation(self) -> Mutatable:
        mutant = self.aPart
        tempAP = mutant.mutation()
        self.kokoro.grimoireMemento.reqquipMutation(tempAP.__class__.__name__)
        return Chi(self.kokoro, self.ofSkill, tempAP)

    # Override
    def myName(self) -> str:
        return self.aPart.myName()


''' DISKILLV2 CLASS '''


class DiSkillV2:
    def __init__(self, kokoro: Kokoro):
        # The variables start with an underscore (_) because they are protected
        self._kokoro = kokoro  # consciousness, shallow ref class to enable interskill communications
        self._diSkillUtils = DISkillUtils()
        self._outAlg = None  # skills output

    def input(self, ear: str, skin: str, eye: str):
        pass

    def output(self, noiron: Neuron):
        if (self._outAlg != None):
            noiron.algParts.append(self._outAlg)
            self._outAlg = None

    def auto(self) -> bool:
        """ does this skill also engage by time triggers ? is it also a level > 1 type of
        # skill ? if yes
        # override me and return true """
        return False


''' CERABELLUM CLASS '''


class Cerabellum:
    # runs an algorithm
    def __init__(self) -> None:
        self.fin: int = None
        self.at: int = None
        self.failType: enumFail = None
        self.incrementAt: bool = False
        self.alg: Algorithm = None
        self.isActive: bool = False
        self.emot: str = ""

    def advanceInAlg(self):
        if (self.incrementAt):
            self.incrementAt = False
            self.at += 1
            if (self.at == self.fin):
                self.isActive = False

    def getAt(self) -> int:
        return self.at

    def getEmot(self) -> str:
        return self.emot

    def setAlgorithm(self, algorithm: Algorithm) -> bool:
        if (not (self.isActive) and (algorithm.getAlgParts != None)):
            self.alg = algorithm
            self.at = 0
            self.fin = algorithm.getSize()
            self.isActive = True
            self.emot = self.alg.getAlgParts[self.at].myName()  # updated line
            return False
        return True

    def isActiveMethod(self) -> bool:
        return self.isActive

    def setActiveOne(self, b1: bool) -> bool:
        return self.isActive == b1

    def setActiveTwo(self, isActive_temp: bool):
        self.isActive = isActive_temp

    def act(self, ear: str, skin: str, eye: str) -> str:
        axnStr: str = ""
        if (not self.isActive):
            return axnStr
        if (self.at < self.fin):
            axnStr = self.alg.getAlgParts[self.at].action(ear, skin, eye)
            self.emot = self.alg.getAlgParts[self.at].myName()
            if (self.alg.getAlgParts[self.at].completed()):
                self.incrementAt = True
        return axnStr

    def getMutationLimitOfActiveAlgPart(self) -> int:
        return self.alg.getAlgParts[self.at].getMutationLimit()

    def getFailType(self) -> enumFail:
        return self.alg.getAlgParts[self.at].failure("")


''' DEXPLORER CLASS '''


class DExplorer(DiSkillV2):
    '''
    D class responsible for mutations of algParts (Mutatable)
    '''

    def __init__(self):
        self.failureCounter: int = 0
        self.prevAP: str = ""

    # Override
    def output(self, noiron: Neuron):
        # TODO Auto-generated method stub
        pass

    # Override
    def input(self, ear: str, skin: str, eye: str):
        # TODO Auto-generated method stub
        pass

    def mutate(self, cera: Cerabellum, failure: enumFail):
        AP: str = cera.getEmot()
        '''
        group relies on a naming convention each class in a mutation series must have
        the same class name concated with a number : APMoan1, APMoan2, APMaon3 ...
        '''
        AP = re.sub(r'\d+', '', AP)  # remove numbers from alg part name to account for overall mutations
        # give up ? :
        if ((self.prevAP.count(AP) != 0) and not (failure.name == enumFail.ok.name)):
            self.failureCounter += 1
            if (self.failureCounter > cera.getMutationLimitOfActiveAlgPart()):
                cera.setActiveTwo(False)
                # this.failureCounter = 0;
        else:
            if (not (self.prevAP.count(AP) != 0)):
                self.failureCounter = 0
        self.prevAP = AP
        if (failure.name == "fail"):
            mutant: Mutatable = cera.alg.getAlgParts().get(cera.getAt())
            cera.alg.getAlgParts().set(cera.getAt(), mutant.mutation())
        elif (failure.name == "cloudian"):
            cera.setActiveTwo(False)


if __name__ == "__main__":
    # Cerabellum test
    print("CERABELLUM TEST ------")
    cerabellum = Cerabellum()
    mut = T1()
    mutList = [mut]
    algo = Algorithm("survive", "representation", mutList)
    print("setAlgorithm method is used: " + str(cerabellum.setAlgorithm(algo)))
    cerabellum.advanceInAlg()
    print("getAt method should return 0: " + str(cerabellum.getAt()))
    print("getEmot method should return T1: " + cerabellum.getEmot())
    print("isActive method should return True: " + str(cerabellum.isActiveMethod()))
    cerabellum.setActiveTwo(False)
    print("act method should return '': " + cerabellum.act("ear", "skin", "eye"))
    print("getMutationLimitOfActiveAlgPart should return 0: " + str(cerabellum.getMutationLimitOfActiveAlgPart()))

    # DExplorer test
    print("\nDEXPLORER TEST ------")
    dex = DExplorer()
    cerabellum.isActive = True
    print("isActive is now true: " + str(cerabellum.isActive) + "\n*mutate method has been called*")
    dex.mutate(cerabellum, enumFail.cloudian)
    print("isActive is now false: " + str(cerabellum.isActive))
    temp1: str = "aptest123"
    print(re.sub(r'\d+', '', temp1))
