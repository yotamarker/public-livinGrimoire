from __future__ import annotations
from abc import ABC, abstractmethod
from enum import Enum
import re

'''
Failure types:
- ok: no fail
- requip: item should be added
- cloudian: algorithm goes to stand by in its Dclass
- fail: no input
'''

class enumFail(Enum):
    fail = "fail"
    requip = "requip"
    dequip = "dequip"
    cloudian = "cloudian"
    ok = "ok"


class Mutatable(ABC):
    @abstractmethod
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        ...

    @abstractmethod
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    @abstractmethod
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    @abstractmethod
    def clone(self) -> Mutatable:
        pass

    def getMutationLimit(self) -> int:
        return 0

    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__

    def mutation(self) -> Mutatable:
        self.clone()


'''!!! CHILD TEST CLASS TO REMOVE !!!'''

class T1(Mutatable):
    def mutation(self) -> Mutatable:
        print("t1 mutating into t2")
        return T2()

    def clone(self) -> Mutatable:
        print("t1 cloning another t1")
        return T1()

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        ...

    # Override
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    # Override
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    # Override
    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__


'''!!! CHILD TEST CLASS TO REMOVE !!!'''

class T2(Mutatable):
    def mutation(self) -> Mutatable:
        print("t2 mutating into t1")
        return T1()

    def clone(self) -> Mutatable:
        print("t2 cloning another t2")
        return T2()

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        ...

    # Override
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    # Override
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    # Override
    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__


class AbsDictionaryDB(ABC):
    @abstractmethod
    def save(self, key: str, value: str):
        '''Returns action string'''
        pass

    @abstractmethod
    def load(self, key: str) -> str:
        '''TODO set to return null as default if key not found !!!'''
        pass


class AbsDictionaryDBShadow(AbsDictionaryDB):
    '''used as a fill in class if you want to test the chobit and havent built a DB class yet'''

    # Override
    def save(self, key: str, value: str):
        pass

    # Override
    def load(self, key: str) -> str:
        return "null"


class GrimoireMemento:
    def __init__(self, absDictionaryDB: AbsDictionaryDB) -> None:
        super().__init__()
        self.rootToAPNumDic = {}  # string, string
        self.APNumToObjDic = {}  # string, Mutatable
        self.absDictionaryDB = absDictionaryDB

    def load(self, obj: Mutatable) -> Mutatable:
        '''load final mutation from memory of obj'''
        objName = obj.__class__.__name__
        objRoot = re.sub(r'\d+', '', objName)
        # if not in active DB try adding from external DB
        if not self.rootToAPNumDic.keys().__contains__(objRoot):
            temp = self.absDictionaryDB.load(objRoot)
            if temp != "null":
                self.rootToAPNumDic[objRoot] = temp

        if (not self.rootToAPNumDic.keys().__contains__(objRoot)):
            self.rootToAPNumDic[objRoot] = objName
            return obj

        if (self.rootToAPNumDic[objRoot] == objName):
            # the mutatable does not have mutations
            return obj
        else:
            APNum = self.rootToAPNumDic[objRoot]
            if (self.APNumToObjDic.keys().__contains__(APNum)):
                return self.APNumToObjDic[APNum].clone()
            else:
                self.loadMutations(obj, objName, objRoot)
                return self.APNumToObjDic[APNum].clone()

    def reqquipMutation(self, mutationAPName: str):
        '''save mutation'''
        self.rootToAPNumDic[re.sub(r'\d+', '', mutationAPName)] = mutationAPName
        self.absDictionaryDB.save(re.sub(r'\d+', '', mutationAPName), mutationAPName)

    def loadMutations(self, obj: Mutatable, objName: str, objRoot: str):
        '''
        make sure all the AP mutation sets of obj are present
        self assumes the last mutation mutates into the prime mutation
        '''
        mutant = obj
        end = objName
        while (True):
            self.APNumToObjDic[obj.__class__.__name__] = obj.clone()
            mutant = obj
            obj = mutant.mutation()
            if (end == obj.__class__.__name__):
                break

    def simpleLoad(self, key: str) -> str:
        return self.absDictionaryDB.load(key)

    def simpleSave(self, key: str, value: str):
        if (key.startswith("AP") or key == "" or value == ""):
            return
        self.absDictionaryDB.save(key, value)


'''
ALGORITHM SECTION
'''

class APVerbatim(Mutatable):
    '''this algorithm part says each past param verbatim'''

    def __init__(self, *args) -> None:
        super().__init__()
        self.sentences = []
        self.at = 0

        try:
            if (isinstance(args[0], list)):
                self.sentences = args[0]
                if (0 == len(self.sentences)):
                    self.at = 30
            else:
                for i in range(len(args)):
                    self.sentences.append(args[i])
        except:
            self.at = 30

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        '''TODO Auto-generated method stub'''
        axnStr = ""
        if (self.at < len(self.sentences)):
            axnStr = self.sentences[self.at]
            self.at += 1
        return axnStr

    # Override
    def failure(self, input: str) -> enumFail:
        '''TODO Auto-generated method stub'''
        return enumFail.ok

    # Override
    def completed(self) -> bool:
        '''TODO Auto-generated method stub'''
        return self.at >= len(self.sentences)

    # Override
    def clone(self) -> AbsAlgPart:
        '''TODO Auto-generated method stub'''
        return APVerbatim(self.sentences)


# A step by step plan to achieve a goal
class Algorithm:

    def __init__(self, goal: str, representation: str, algParts: list[Mutatable]):    # list of Mutatable
        super().__init__()
        self.goal = goal
        self.representation = representation
        self.algParts = algParts

    # *constract with string and goal
    @property
    def getGoal(self) -> str:
        return self.goal

    @property
    def getRepresentation(self) -> str:
        return self.representation

    @property
    def getAlgParts(self) -> list[Mutatable]:
        return self.algParts

    def getSize(self) -> int:
        return len(self.algParts)

    def clone(self) -> Algorithm:
        parts = []    # list of Mutatable
        for mutatable in self.algParts:
            parts.append(mutatable.clone())
        return Algorithm(self.goal, self.getRepresentation, parts)


if __name__ == "__main__":
    testOne = APVerbatim("hello")
    testTwo = T1()
    testThree = T2()
    testList = [testOne, testTwo, testThree]
    algorithm = Algorithm("goal", "representation", testList)

    # Printing
    print(algorithm.getAlgParts[0].action("","",""))
    print("This should return 'goal': " + algorithm.getGoal)
    print("This should return 'representation': " + algorithm.getRepresentation)
    print("This should return a list containing 3 objects: " + str(algorithm.getAlgParts))
    print("This should return 3: " + str(algorithm.getSize()))
    algorithmTwo = algorithm.clone()

    # Clone printing
    print("\nThis should return 'goal': " + algorithmTwo.getGoal)
    print("This should return 'representation': " + algorithmTwo.getRepresentation)
    print("This should return a list containing 3 objects: " + str(algorithmTwo.getAlgParts))
    print("This should return 3: " + str(algorithmTwo.getSize()))