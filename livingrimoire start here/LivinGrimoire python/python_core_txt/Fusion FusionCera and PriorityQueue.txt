from __future__ import annotations
from abc import ABC, abstractmethod
from enum import Enum
from typing import Iterable
import re



''' ENUMFAIL CLASS '''
class enumFail(Enum):
    fail = "fail"    # no input
    requip = "requip"    # item should be added
    dequip = "dequip"
    cloudian = "cloudian"    # algorithm goes to stand by in its Dclass
    ok = "ok"    # no fail


''' MUTATABLE CLASS '''
class Mutatable(ABC):
    @abstractmethod
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        pass

    @abstractmethod
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    @abstractmethod
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    @abstractmethod
    def clone(self) -> Mutatable:
        pass

    def getMutationLimit(self) -> int:
        return 0

    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__

    def mutation(self) -> Mutatable:
        self.clone()


'''!!! CHILD TEST CLASS TO REMOVE !!!'''
class T1(Mutatable):
    def mutation(self) -> Mutatable:
        print("t1 mutating into t2")
        return T2()

    def clone(self) -> Mutatable:
        print("t1 cloning another t1")
        return T1()

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        pass

    # Override
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    # Override
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    # Override
    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__


'''!!! CHILD TEST CLASS TO REMOVE !!!'''
class T2(Mutatable):
    def mutation(self) -> Mutatable:
        print("t2 mutating into t1")
        return T1()

    def clone(self) -> Mutatable:
        print("t2 cloning another t2")
        return T2()

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        """Returns action string"""
        pass

    # Override
    def failure(self, input: str) -> enumFail:
        """Failure type only mutatable may use enumFail.fail"""
        pass

    # Override
    def completed(self) -> bool:
        """Has finished ?"""
        pass

    # Override
    def myName(self) -> str:
        """Returns the class name"""
        return self.__class__.__name__


''' ABSDICTIONARYDB CLASS '''
class AbsDictionaryDB(ABC):
    @abstractmethod
    def save(self, key: str, value: str):
        '''Returns action string'''
        pass

    @abstractmethod
    def load(self, key: str) -> str:
        '''TODO set to return null as default if key not found !!!'''
        pass


''' ABSDICTIONARYDBSHADOW CLASS '''
class AbsDictionaryDBShadow(AbsDictionaryDB):
    '''used as a fill in class if you want to test the chobit and havent built a DB class yet'''

    # Override
    def save(self, key: str, value: str):
        pass

    # Override
    def load(self, key: str) -> str:
        return "null"


''' GRIMOIREMEMENTO CLASS '''
class GrimoireMemento:
    def __init__(self, absDictionaryDB: AbsDictionaryDB) -> None:
        super().__init__()
        self.rootToAPNumDic = {}  # string, string
        self.APNumToObjDic = {}  # string, Mutatable
        self.absDictionaryDB = absDictionaryDB

    def load(self, obj: Mutatable) -> Mutatable:
        '''load final mutation from memory of obj'''
        objName = obj.__class__.__name__
        objRoot = re.sub(r'\d+', '', objName)
        # if not in active DB try adding from external DB
        if not self.rootToAPNumDic.keys().__contains__(objRoot):
            temp = self.absDictionaryDB.load(objRoot)
            if temp != "null":
                self.rootToAPNumDic[objRoot] = temp

        if (not self.rootToAPNumDic.keys().__contains__(objRoot)):
            self.rootToAPNumDic[objRoot] = objName
            return obj

        if (self.rootToAPNumDic[objRoot] == objName):
            # the mutatable does not have mutations
            return obj
        else:
            APNum = self.rootToAPNumDic[objRoot]
            if (self.APNumToObjDic.keys().__contains__(APNum)):
                return self.APNumToObjDic[APNum].clone()
            else:
                self.loadMutations(obj, objName, objRoot)
                return self.APNumToObjDic[APNum].clone()

    def reqquipMutation(self, mutationAPName: str):
        '''save mutation'''
        self.rootToAPNumDic[re.sub(r'\d+', '', mutationAPName)] = mutationAPName
        self.absDictionaryDB.save(re.sub(r'\d+', '', mutationAPName), mutationAPName)

    def loadMutations(self, obj: Mutatable, objName: str, objRoot: str):
        '''
        make sure all the AP mutation sets of obj are present
        self assumes the last mutation mutates into the prime mutation
        '''
        mutant = obj
        end = objName
        while (True):
            self.APNumToObjDic[obj.__class__.__name__] = obj.clone()
            mutant = obj
            obj = mutant.mutation()
            if (end == obj.__class__.__name__):
                break

    def simpleLoad(self, key: str) -> str:
        return self.absDictionaryDB.load(key)

    def simpleSave(self, key: str, value: str):
        if (key.startswith("AP") or key == "" or value == ""):
            return
        self.absDictionaryDB.save(key, value)


''' APVERBATIM CLASS '''
class APVerbatim(Mutatable):
    '''this algorithm part says each past param verbatim'''

    def __init__(self, *args) -> None:
        super().__init__()
        self.sentences = []
        self.at = 0

        try:
            if (isinstance(args[0], list)):
                self.sentences = args[0]
                if (0 == len(self.sentences)):
                    self.at = 30
            else:
                for i in range(len(args)):
                    self.sentences.append(args[i])
        except:
            self.at = 30

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        '''TODO Auto-generated method stub'''
        axnStr = ""
        if (self.at < len(self.sentences)):
            axnStr = self.sentences[self.at]
            self.at += 1
        return axnStr

    # Override
    def failure(self, input: str) -> enumFail:
        '''TODO Auto-generated method stub'''
        return enumFail.ok

    # Override
    def completed(self) -> bool:
        '''TODO Auto-generated method stub'''
        return self.at >= len(self.sentences)

    # Override
    def clone(self) -> Mutatable:
        '''TODO Auto-generated method stub'''
        return APVerbatim(self.sentences)


''' ALGORITHM CLASS '''
# A step by step plan to achieve a goal
class Algorithm:

    def __init__(self, goal: str, representation: str, algParts: list[Mutatable]):    # list of Mutatable
        super().__init__()
        self.goal = goal
        self.representation = representation
        self.algParts = algParts

    # *constract with string and goal
    @property
    def getGoal(self) -> str:
        return self.goal

    @property
    def getRepresentation(self) -> str:
        return self.representation

    @property
    def getAlgParts(self) -> list[Mutatable]:
        return self.algParts

    def getSize(self) -> int:
        return len(self.algParts)

    def clone(self) -> Algorithm:
        parts = []    # list of Mutatable
        for mutatable in self.algParts:
            parts.append(mutatable.clone())
        return Algorithm(self.goal, self.getRepresentation, parts)


''' CLDBOOL CLASS '''
class CldBool:
    # cloudian : this class is used to provide shadow reference to a boolean variable
    def __init__(self):
        self.modeActive = False
    @property
    def getModeActive(self) -> bool:
        return self.modeActive

    def setModeActive(self, modeActive: bool):
        self.modeActive = modeActive


''' APCLDVERBATIM CLASS '''
class APCldVerbatim(Mutatable):
    '''this algorithm part says each string param verbatim'''
    def __init__(self, cldBool: CldBool, *words):
        super().__init__()
        self.sentences = []
        self.at = 0
        self.cldBool = cldBool

        try:
            if (isinstance(words[0], list)):
                self.sentences = words[0]
                self.cldBool.setModeActive(True)
            else:
                for i in range(len(words)):
                    self.sentences.append(words[i])
                self.cldBool.setModeActive(True)
        except:
            self.at = 30

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        # TODO Auto-generated method stub
        axnStr = ""
        if (self.at < len(self.sentences)):
            axnStr = self.sentences[self.at]
            self.at += 1

        self.cldBool.setModeActive(not (self.at >= len(self.sentences)))
        return axnStr

    # Override
    def failure(self, input: str) -> enumFail:
        # TODO Auto-generated method stub
        return enumFail.ok

    # Override
    def completed(self) -> bool:
        return self.at >= len(self.sentences)

    # Override
    def clone(self) -> Mutatable:
        # TODO Auto-generated method stub
        return APCldVerbatim(self.cldBool, self.sentences)


''' NEURON CLASS '''
# used to transport algorithms to other classes
class Neuron:
    def __init__(self) -> None:
        self.algParts: list[Algorithm] = []
        self.negativeAlgParts: list[Algorithm] = []

    def empty(self):
        self.algParts.clear()
        self.negativeAlgParts.clear()


''' DISKILLUTILS CLASS '''
class DISkillUtils:
    def verbatimGorithmOne(self, itte: Mutatable) -> Algorithm:
        # returns a simple algorithm containing 1 alg part
        representation = "util"
        algParts1: list[Mutatable] = []
        algParts1.append(itte)
        algorithm = Algorithm("util", representation, algParts1)
        return algorithm

    def verbatimGorithmTwo(self, algMarker: str, itte: Mutatable) -> Algorithm:
        # returns a simple algorithm for saying sent parameter
        representation = "util"
        algParts1: list[Mutatable] = []
        algParts1.append(itte)
        algorithm = Algorithm("util", representation, algParts1)
        return algorithm

    def customizedVerbatimGorithm(self, algMarker: str, itte: Mutatable) -> Algorithm:
        # the most stable and advanced algorithm builder
        # returns a simple algorithm containing 1 alg part
        representation = "r_" + algMarker
        algParts1: list[Mutatable] = []
        algParts1.append(itte)
        algorithm = Algorithm(algMarker, representation, algParts1)
        return algorithm

    def customizedVerbatimGorithm(self, algMarker: str, *itte: Mutatable) -> Algorithm:
        # the most stable and advanced algorithm builder
        # returns a simple algorithm containing 1 alg part
        representation = "r_" + algMarker
        algParts1: list[Mutatable] = []
        for i in range (len(itte)):
            algParts1.append(itte[i])
        algorithm = Algorithm(algMarker, representation, algParts1)
        return algorithm

    def simpleVerbatimAlgorithm(self, algMarker: str, *sayThis) -> Algorithm:
        # returns alg that says the word string (sayThis)
        return self.customizedVerbatimGorithm(algMarker, APVerbatim(*sayThis))

    def simpleCloudiandVerbatimAlgorithm(self, cldBool: CldBool, algMarker: str, *sayThis) -> Algorithm:
        # returns alg that says the word string (sayThis)
        return self.customizedVerbatimGorithm(algMarker, APCldVerbatim(cldBool, *sayThis))

    def strContainsList(self, str1: str, items: list[str]) -> str:
        # returns the 1st match between words in a string and values in a list.
        for temp in items:
            if (str1.count(temp) > 0):
                return temp
        return ""


''' KOKORO CLASS '''
'''
all action data goes through here
 * detects negatives such as : repetition, pain on various levels and failures
 * serves as a database for memories, convos and alg generations
 * can trigger revenge algs
 * checks for % of difference in input for exploration type algs
'''
class Kokoro:
    def __init__(self, absDictionaryDB: AbsDictionaryDB):
        self.emot = ""
        self.pain:dict[str, int] = {}
        self.grimoireMemento = GrimoireMemento(absDictionaryDB)
        self.toHeart:dict[str, str] = {}
        self.fromHeart:dict[str, str] = {}
        self.standBy = False

    def getEmot(self) -> str:
        return self.emot

    def setEmot(self, emot: str):
        self.emot = emot

    def getPain(self, BijuuName: str) -> int:
        try:
            value = self.pain[BijuuName]
        except:
            value = 0
        return value

    def inside(self, chi: Chi):
        pass

    def outside(self, isCompleted: bool, failure: enumFail):
        pass


''' CHI CLASS '''
class Chi(Mutatable):
    '''
    an adaptor pattern to the alg part, it also has the kokoro consiousness
    object to be aware throughout the program of what is happening all action
    data goes through this soul.
    '''
    def __init__(self, kokoro: Kokoro, ofSkill: str, aPart: Mutatable):
        super().__init__()
        self.kokoro = kokoro
        self.ofSkill = ofSkill
        self.aPart = kokoro.grimoireMemento.load(aPart)

    def actualAction(self, ear: str, skin: str, eye: str) -> str:
        return self.aPart.action(ear, skin, eye)

    # Override
    def action(self, ear: str, skin: str, eye: str) -> str:
        self.kokoro.inside(self)
        result = self.actualAction(ear, skin, eye)
        self.kokoro.outside(self.completed(), self.failure(""))
        return result

    # Override
    def failure(self, input: str) -> enumFail:
        # TODO Auto-generated method stub
        return self.aPart.failure(input)

    # Override
    def completed(self) -> bool:
        # TODO Auto-generated method stub
        return self.aPart.completed()

    # Override
    def clone(self) -> Mutatable:
        # TODO Auto-generated method stub
        return Chi(self.kokoro, self.ofSkill, self.aPart.clone())

    # Override
    def getMutationLimit(self) -> int:
        # TODO Auto-generated method stub
        return self.aPart.getMutationLimit()

    # Override
    def mutation(self) -> Mutatable:
        mutant = self.aPart
        tempAP = mutant.mutation()
        self.kokoro.grimoireMemento.reqquipMutation(tempAP.__class__.__name__)
        return Chi(self.kokoro, self.ofSkill, tempAP)

    # Override
    def myName(self) -> str:
        return self.aPart.myName()


''' DISKILLV2 CLASS '''
class DiSkillV2:
    def __init__(self, kokoro: Kokoro):
        # The variables start with an underscore (_) because they are protected
        self._kokoro = kokoro # consciousness, shallow ref class to enable interskill communications
        self._diSkillUtils = DISkillUtils()
        self._outAlg = None # skills output

    def input(self, ear: str, skin: str, eye: str):
        pass

    def output(self, noiron: Neuron):
        if (self._outAlg != None):
            noiron.algParts.append(self._outAlg)
            self._outAlg = None

    def auto(self) -> bool:
        """ does this skill also engage by time triggers ? is it also a level > 1 type of
        # skill ? if yes
        # override me and return true """
        return False


''' CERABELLUM CLASS '''
class Cerabellum:
    # runs an algorithm
    def __init__(self) -> None:
        self.fin: int = None
        self.at: int = None
        self.failType: enumFail = None
        self.incrementAt: bool = False
        self.alg: Algorithm = None
        self.isActive: bool = False
        self.emot: str = ""

    def advanceInAlg(self):
        if (self.incrementAt):
            self.incrementAt = False
            self.at += 1
            if (self.at == self.fin):
                self.isActive = False

    def getAt(self) -> int:
        return self.at

    def getEmot(self) -> str:
        return self.emot

    def setAlgorithm(self, algorithm: Algorithm) -> bool:
        if (not(self.isActive) and (algorithm.getAlgParts != None)):
            self.alg = algorithm
            self.at = 0
            self.fin = algorithm.getSize()
            self.isActive = True
            self.emot = self.alg.getAlgParts[self.at].myName() # updated line
            return False
        return True

    def isActiveMethod(self) -> bool:
        return self.isActive

    def setActiveOne(self, b1: bool) -> bool:
        return self.isActive == b1

    def setActiveTwo(self, isActive: bool):
        self.isActive = isActive

    def act(self, ear: str, skin: str, eye: str) -> str:
        axnStr: str = ""
        if (not self.isActive):
            return axnStr
        if (self.at < self.fin):
            axnStr = self.alg.getAlgParts[self.at].action(ear, skin, eye)
            self.emot = self.alg.getAlgParts[self.at].myName()
            if (self.alg.getAlgParts[self.at].completed()):
                self.incrementAt = True
                # at++;
                # if (at == fin) {
                # isActive = false;
                # }
        return axnStr

    def getMutationLimitOfActiveAlgPart(self) -> int:
        return self.alg.getAlgParts[self.at].getMutationLimit()

    def getFailType(self) -> enumFail:
        return self.alg.getAlgParts[self.at].failure("")


''' DEXPLORER CLASS '''
class DExplorer(DiSkillV2):
    '''
    D class responsible for exploring :
    learning, mutating algorithms, requiping APs with objects or skill mods
    the sould resides here
    '''
    def __init__(self):
        self.failureCounter: int = 0
        self.prevAP: str = ""

    #Override
    def output(self, noiron: Neuron):
        # TODO Auto-generated method stub
        pass

    #Override
    def input(self, ear: str, skin: str, eye: str):
        # TODO Auto-generated method stub
        pass

    def mutate(self, cera: Cerabellum, failure: enumFail):
        AP: str = cera.getEmot()
        '''
        group relies on a naming convention each class in a mutation series must have
        the same class name concated with a number : APMoan1, APMoan2, APMaon3 ...
        '''
        AP = AP.replace(r"\\d+", "")
        # give up ? :
        if ((self.prevAP.count(AP) != 0) and not(failure.name == enumFail.ok.name)):
            self.failureCounter += 1
            if (self.failureCounter > cera.getMutationLimitOfActiveAlgPart()):
                cera.setActiveTwo(False)
                # this.failureCounter = 0;
        else:
            if (not (self.prevAP.count(AP) != 0)):
                self.failureCounter = 0
        self.prevAP = AP
        if (failure.name == "fail"):
            mutant: Mutatable = Mutatable(cera.alg.getAlgParts().get(cera.getAt()))
            cera.alg.getAlgParts().set(cera.getAt(), mutant.mutation())
        elif (failure.name == "cloudian"):
            cera.setActiveTwo(False)


''' PRIORITYQUEUE CLASS '''
# A simple implementation of Priority Queue
# using Queue.
class PriorityQueue(object):
    def __init__(self):
        self.queue = []

    def __str__(self):
        return ' '.join([str(i) for i in self.queue])

    # for checking if the queue is empty
    def isEmpty(self):
        return len(self.queue) == 0

    # for inserting an element in the queue
    def insert(self, data):
        self.queue.append(data)

    # for popping an element based on Priority
    def poll(self) -> object:
        if not len(self.queue) == 0:
            result0 = self.queue[0]
            del self.queue[0]
            return result0
        return None


''' FUSION CLASS '''
class Fusion:
    '''
     * fuses algorithms and sends needed algorithm to a designated cerabellum
     * object for activation
    '''
    def __init__(self, algDurations: dict[str, int]):
        self.AlgDurations: dict[str, int] = None
        self.AlgDurations2: dict[str, int] = {}
        self.emot: str = ""
        self.algQueue: PriorityQueue = PriorityQueue()   # PriorityQueue[Algorithm]
        self.dangerAlgQueue: PriorityQueue = PriorityQueue()   # PriorityQueue[Algorithm]
        self.reqOverload: bool = False # too many requests
        self.repReq: bool = False # chobit has already accepted this request
        self.represantations: list[str] = []
        self.dExplorer: DExplorer = DExplorer()
        self.goalsToTrack: list[str] = ["", ""] # dangerCera, mainCera
        # cerabellums :
        self.dangerCera: Cerabellum = Cerabellum()
        # requip cera
        # fusionCera = (Cerabellum) (new FusionCera(algQueue));
        self.fusionCera: FusionCera = FusionCera(self.algQueue)
        self.mainCera: Cerabellum = Cerabellum()
        # home cera
        # cera = { dangerCera, fusionCera, mainCera };
        self.cera: list[Cerabellum] = [self.dangerCera, self.fusionCera, self.mainCera]
        # end cerabellums
        self.AlgDurations: dict[str, int] = algDurations

    def setAlgQueue(self, shinkei: Neuron):
        # populate cerabellums with algorithms from queues
        for algorithm in shinkei.negativeAlgParts:
            if (len(self.dangerAlgQueue.queue) < 1):
                self.dangerAlgQueue.insert(algorithm.clone())
            else:
                break

        self.repReq = False
        for algorithm in shinkei.algParts:
            self.updateRepresentations()
            if (self.represantations.count(algorithm.getRepresentation) > 0):
                self.repReq = True
                # System.out.println("again with this poo ?");
                continue
            if (len(self.algQueue.queue) < 5):
                self.algQueue.insert(algorithm.clone())
            else:
                break

        self.reqOverload = len(self.algQueue.queue) > 4 and len(shinkei.algParts) > 0
        # empty Neuron
        shinkei.empty()
        if (not(self.dangerCera.isActiveMethod()) and (not(len(self.dangerAlgQueue.queue) == 0))):
            self.dangerCera.setAlgorithm(self.dangerAlgQueue.poll())
            self.goalsToTrack[0] = self.dangerCera.alg.getGoal
            self.goalTrack(self.goalsToTrack[0])
        if (not self.mainCera.isActiveMethod() and not (len(self.algQueue.queue) == 0)):
            self.mainCera.setAlgorithm(self.algQueue.poll())
            self.goalsToTrack[1] = self.mainCera.alg.getGoal
            self.goalTrack(self.goalsToTrack[1])
        self.fuze()

    def getRepReq(self) -> bool:
        # were the same algorithms repeatedly requested ? were the AI negged ?
        return self.repReq

    def getReqOverload(self) -> bool:
        # too many algorithms requested for the time being, queue overlaod (>5 algs)
        return self.reqOverload

    def act(self, ear: str, skin: str, eye: str) -> str:
        result: str = ""
        for i in range(len(self.cera)):
            if (self.cera[i].isActiveMethod()):
                result = self.cera[i].act(ear, skin, eye)
                self.dExplorer.mutate(self.cera[i], self.cera[i].getFailType())
                self.cera[i].advanceInAlg()
                self.emot = self.cera[i].getEmot()
                if (i > 1):
                    n1: int = self.AlgDurations2[self.cera[i].alg.getGoal]
                    self.AlgDurations2[self.cera[i].alg.getGoal] = n1 + 1
                break
            # else(cera notactive) try go home
        return result

    def getEmot(self) -> str:
        return self.emot

    def updateRepresentations(self):
        for algorithm in self.algQueue.queue:
            self.represantations.append(algorithm.getRepresentation)

    def goalTrack(self, goal: str):
        if (not goal in self.AlgDurations2):
            # try to load, if failed :
            self.AlgDurations[goal] = 0
            self.AlgDurations2[goal] = 0
        else:
            self.AlgDurations[goal] = self.AlgDurations2[goal]

    def goalTrackReset(self, goal: str) -> str:
        if (not goal == ""):
            self.AlgDurations2[goal] = 0
        return ""

    def fuze(self):
        if (self.mainCera.isActiveMethod() and not self.fusionCera.isActiveMethod()):
            algRunTime: int = self.AlgDurations[self.mainCera.alg.getGoal]
            algRunTime = algRunTime / 2
            alg1: Algorithm = None
            g1: str = ""
            time1: int = 0
            iterator: Iterable[Algorithm] = iter(self.algQueue.queue)    # Iterator<Algorithm>
            for element in iterator:
                alg1 = element
                g1 = alg1.getGoal
                self.goalTrack(g1)
                time1 = self.AlgDurations[g1]
                if (time1 < algRunTime):
                    self.fusionCera.setAlgorithm(alg1)
                    self.algQueue.queue.remove(alg1)
                    self.fusionCera.setAbort(time1)
                    self.goalTrackReset(g1)
                    break

        self.goalsToTrack[0] = self.goalTrackReset(self.goalsToTrack[0])
        self.goalsToTrack[1] = self.goalTrackReset(self.goalsToTrack[1])


''' FUSIONCERA CLASS '''
class FusionCera(Cerabellum):

    def __init__(self, algQueue: PriorityQueue):
        super().__init__()
        self.abort: int = 0
        self.algQueue: PriorityQueue = algQueue  # PriorityQueue<Algorithm>

    def setAbort(self, abort: int):
        self.abort = abort + 1

    # Override
    def act(self, ear: str, skin: str, eye: str) -> str:
        # TODO Auto-generated method stub
        result: str = super().act(ear, skin, eye)
        self.abort -= 1
        if (self.abort < 1):
            self.setActiveTwo(False)
        else:
            if (not self.isActiveMethod()):
                try:
                    self.algQueue.queue.remove(self.alg)
                except:
                    pass
        return result



if __name__ == "__main__":
    print("\n--- TESTING FUSION ---\n")
    dictionary = {"string" : 5}
    neuron = Neuron()
    fusion = Fusion(dictionary)
    ds:DISkillUtils = DISkillUtils()
    alg1:Algorithm = ds.simpleVerbatimAlgorithm("test","hello","hi there", "to you")
    neuron.algParts.append(alg1)
    danger_alg:Algorithm = ds.simpleVerbatimAlgorithm("test","hadoken")
    neuron.negativeAlgParts.append(danger_alg)
    fusion.setAlgQueue(neuron)
    print(fusion.getRepReq())
    result:str = fusion.act("","","")
    print(result)
    neuron = Neuron()
    fusion.setAlgQueue(neuron)
    result = fusion.act("", "", "")
    print(result)
    print(fusion.getRepReq())
    result = fusion.act("", "", "")
    result = fusion.act("", "", "")
    result = fusion.act("", "", "")
    result = fusion.act("", "", "")
    alg2: Algorithm = ds.simpleVerbatimAlgorithm("test2", "just hi")
    neuron.algParts.append(alg1)
    neuron.algParts.append(alg2)
    fusion.setAlgQueue(neuron)
    result = fusion.act("", "", "")
    print(result)


    print("\n\n--- TESTING FUSIONCERA ---\n")
    muta = T1()
    algo = ds.simpleVerbatimAlgorithm("strange_test","hi")
    fusionCera = FusionCera([algo])
    fusionCera.setAbort(3)
    print("abort should be 4: " + str(fusionCera.abort))
    result = fusionCera.act("", "", "")